<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<meta name="author" content="Non-intrusive signal programming library for C++11">
<title>Synapse</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Synapse</h1>
<div class="details">
<span id="author" class="author">Non-intrusive signal programming library for C++11</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#_abstract">Abstract</a></li>
<li><a href="#_tutorial">Tutorial</a>
<ul class="sectlevel2">
<li><a href="#_signals_emitters_receivers">Signals, emitters, receivers</a></li>
<li><a href="#_emitting_signals_from_objects_of_3rd_party_types">Emitting signals from objects of 3rd-party types</a></li>
<li><a href="#_managing_connection_lifetime">Managing connection lifetime</a></li>
<li><a href="#_blocking_of_signals">Blocking of signals</a></li>
<li><a href="#_meta_signals">Meta signals</a></li>
<li><a href="#_interthread_communication">Interthread communication</a>
<ul class="sectlevel3">
<li><a href="#_emitting_signals_across_thread_boundaries">Emitting signals across thread boundaries</a></li>
<li><a href="#_scheduling_function_calls_across_thread_boundaries">Scheduling function calls across thread boundaries</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_building">Building</a></li>
<li><a href="#_portability">Portability</a></li>
<li><a href="#_synopsis">Synopsis</a></li>
<li><a href="#_reference">Reference</a>
<ul class="sectlevel2">
<li><a href="#emit"><code>emit</code></a></li>
<li><a href="#connect"><code>connect</code></a></li>
<li><a href="#translate"><code>translate</code></a></li>
<li><a href="#connection"><code>connection</code></a>
<ul class="sectlevel3">
<li><a href="#connection::set_user_data"><code>set_user_data</code></a></li>
<li><a href="#connection::get_user_data"><code>get_user_data</code></a></li>
<li><a href="#connection::emitter"><code>emitter</code></a></li>
<li><a href="#connection::receiver"><code>receiver</code></a></li>
</ul>
</li>
<li><a href="#pconnection"><code>pconnection</code></a></li>
<li><a href="#block"><code>block</code></a></li>
<li><a href="#blocker"><code>blocker</code></a>
<ul class="sectlevel3">
<li><a href="#blocker::emitter"><code>emitter</code></a></li>
</ul>
</li>
<li><a href="#thread_local_queue"><code>thread_local_queue</code></a>
<ul class="sectlevel3">
<li><a href="#create_thread_local_queue"><code>create_thread_local_queue</code></a></li>
<li><a href="#poll"><code>poll</code></a></li>
<li><a href="#wait"><code>wait</code></a></li>
<li><a href="#post"><code>post</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_programming_techniques">Programming techniques</a>
<ul class="sectlevel2">
<li><a href="#_synapsifying_c_callbacks">Synapsifying C callbacks</a></li>
<li><a href="#_reporting_exceptions_from_code_noexcept_code_signal_handlers">Reporting exceptions from <code>noexcept</code> signal handlers</a></li>
<li><a href="#_using_synapse_with_qt_to_avoid_mocing">Using Synapse with Qt to avoid MOCing</a></li>
</ul>
</li>
<li><a href="#_examples">Examples</a>
<ul class="sectlevel2">
<li><a href="#_glfw">GLFW</a></li>
</ul>
</li>
<li><a href="#_q_a">Q&amp;A</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_abstract">Abstract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(Note: Synapse is not part of Boost. Please post questions and suggestions on the Boost Developers Mailing List).</p>
</div>
<div class="paragraph">
<p>Synapse is a C++ signal programming library. It can be used to define communication channels between objects of arbitrary types in a dynamic object environment.</p>
</div>
<div class="paragraph">
<p>Synapse is non-intrusive: it allows any object of any type whatsoever to be used as a signal emitter: if two contexts in a given program happen to have access to the same object, they can use that object to communicate through Synapse signals.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial">Tutorial</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_signals_emitters_receivers">Signals, emitters, receivers</h3>
<div class="paragraph">
<p>In Synapse, signals are defined by function pointer typedefs. The return type is used to tell apart different signals that have otherwise identical signature.</p>
</div>
<div class="paragraph">
<p>To emit a signal, we instantiate the <code>emit</code> function template with a signal type, passing the emitter object as the first argument. The rest of the arguments follow, as defined by the signal signature.</p>
</div>
<div class="paragraph">
<p>Below we define a UI type <code>button</code> that emits a Synapse signal <code>clicked</code> (which takes no arguments) when the member function <code>click</code> is called:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">class</span> <span class="class">button</span> {

    <span class="directive">public</span>:

    <span class="keyword">typedef</span> <span class="keyword">struct</span> clicked_(*clicked)();

    <span class="directive">void</span> click() {
        synapse::emit&lt;clicked&gt;(<span class="local-variable">this</span>);
    }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>To receive a signal emitted by an object, we need to connect at least one function to it. Emitting a signal calls all conected functions, in the order in which the connections were created.</p>
</div>
<div class="paragraph">
<p>Below, we connect the signal <code>button::clicked</code> to the <code>accept</code> member function of a dialog box object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">class</span> <span class="class">dialog</span> {

    <span class="directive">public</span>:

    <span class="directive">void</span> accept();

};

....
shared_ptr&lt;button&gt; emitter=make_shared&lt;button&gt;();
shared_ptr&lt;dialog&gt; receiver=make_shared&lt;dialog&gt;();
synapse::connect&lt;button::clicked&gt;(emitter, receiver, &amp;dialog::accept);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or we could use a lambda instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">synapse::connect&lt;button::clicked&gt;(emitter, receiver,
    [ ](dialog &amp; d) {
        d.accept();
    } );</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>receiver</code> argument to <code>connect</code> is optional. If it is specified, it is dereferenced and passed as the first argument to the connected function, prepending all other arguments as specified by the signal signature.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_emitting_signals_from_objects_of_3rd_party_types">Emitting signals from objects of 3rd-party types</h3>
<div class="paragraph">
<p>In Synapse, any object whatsoever can be used as an emitter. This makes it possible to <code>emit</code> non-intrusively even if the emitter object was not designed to support signals. For example, a function that processes a file can use the standard <code>FILE</code> pointer as a Synapse emitter to report on its progress:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> report_progress_(*report_progress)(<span class="predefined-type">int</span>);

<span class="directive">void</span> process_file( FILE * f ) {

    <span class="keyword">for</span>( <span class="predefined-type">int</span> progress=<span class="integer">0</span>; !feof(f); ) {
        ....
        progress += fread(buf,<span class="integer">1</span>,nread,f);
        ....
        synapse::emit&lt;report_progress&gt;(f,progress);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Outside of <code>process_file</code> the <code>report_progress</code> signal can be connected to some user interface function that updates a progress bar. Using Qt, this could look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">if</span>( FILE * f=fopen(<span class="string"><span class="delimiter">&quot;</span><span class="content">file.dat</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">rb</span><span class="delimiter">&quot;</span></span>) ) {
    QProgressBar pb(....);
    <span class="directive">auto</span> c=synapse::connect&lt;report_progress&gt;(f, &amp;pb,
                &amp;QProgressBar::setValue);
    process_file(f);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that <code>process_file</code> is not coupled with <code>QProgressBar</code>: the <code>report_progress</code> signal could be connected to a different function or not connected at all, in which case the call to <code>emit</code> would be a no-op.</p>
</div>
</div>
<div class="sect2">
<h3 id="_managing_connection_lifetime">Managing connection lifetime</h3>
<div class="paragraph">
<p>In Synapse there are two types of connection objects: <a href="#connection"><code>connection</code></a> and <a href="#pconnection"><code>pconnection</code></a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>shared_ptr&lt;<a href="#connection">connection</a>&gt;</code> objects are returned by overloads of <a href="#connect"><code>connect</code></a> which take the emitter (and, if specified, the receiver) as a raw pointer. The user is required to keep this object afloat; the signal is disconnected when it expires.</p>
</li>
<li>
<p><code>weak_ptr&lt;<a href="#pconnection">pconnection</a>&gt;</code> objects are returned by overloads of <a href="#connect"><code>connect</code></a> which take at least one of the emitter or the receiver as a <code>weak_ptr</code> or <code>shared_ptr</code>. The user is not required to keep this object afloat; the connection is disconnected when Synapse detects that the emitter or the receiver have expired.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="#release"><code>release</code></a> function can be used to convert a <a href="#pconnection"><code>pconnection</code></a> object to a <a href="#connection"><code>connection</code></a> object.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_blocking_of_signals">Blocking of signals</h3>
<div class="paragraph">
<p>It is possible to temporarily block a specific signal for a specific emitter. This allows to dynamically disable functionality implemented by emitting signals&#8201;&#8212;&#8201;without having to disconnect them.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Blocking affects pre-existing as well as future connections.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="preprocessor">#include</span> <span class="include">&lt;boost/synapse/connect.hpp&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;boost/synapse/block.hpp&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;string&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;iostream&gt;</span>

<span class="keyword">namespace</span> synapse = boost::synapse;

<span class="keyword">typedef</span> <span class="keyword">struct</span> print_(*print)(std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; s);

<span class="predefined-type">int</span> main() {

    <span class="predefined-type">int</span> emitter;

    <span class="directive">auto</span> c = synapse::connect&lt;my_signal&gt;(&amp;emitter,
        [ ](std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; s) {
            std::cout &lt;&lt; s;
        } );

    synapse::emit&lt;print&gt;(&amp;emitter,<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>

    shared_ptr&lt;synapse::blocker&gt; b = synapse::block&lt;print&gt;(&amp;emitter); <i class="conum" data-value="2"></i><b>(2)</b>
    synapse::emit&lt;print&gt;(&amp;emitter,<span class="string"><span class="delimiter">&quot;</span><span class="content">NOOP</span><span class="delimiter">&quot;</span></span>);

    b.reset();
    synapse::emit&lt;print&gt;(&amp;emitter,<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>emit</code> calls the connected lambda, printing <code>Hello World</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>print</code> signal will be blocked until <code>b</code> expires, therefore the call to <code>emit</code> on the next line is a noop, even though <code>c</code> has not expired (meaning, the signal is still connected.)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>At this point <code>b</code> has expired, so the call to <code>emit</code> will call the connected lambda, printing <code>Hello World</code>, again.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_meta_signals">Meta signals</h3>
<div class="paragraph">
<p>Synapse features a special global emitter that emits meta signals to notify connected functions about user interactions with other signals. It can be accessed by the <code>meta::emitter</code> function.</p>
</div>
<div class="paragraph">
<p>When a <code>Signal</code> is blocked or unblocked, the meta emitter emits the <code>meta::blocked&lt;Signal&gt;</code> signal. Connecting this signal allows the blocked state of the signal to be automatically reflected in other systems, for example user interface.</p>
</div>
<div class="paragraph">
<p>Similarly, when a <code>Signal</code> is connected or disconnected, the meta emitter emits the <a href="#meta::connected"><code>meta::connected&lt;Signal&gt;</code></a>. This meta signal is useful for integrating Synapse with 3rd-party callback systems; see <a href="#_synapsifying_c_callbacks">Synapsifying C callbacks</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To further facilitate the integration of Synapse with 3rd-partty callback systems, <code>connection</code>  objects (returned by the <code>connect</code> function) can store arbitrary user data.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_interthread_communication">Interthread communication</h3>
<div class="sect3">
<h4 id="_emitting_signals_across_thread_boundaries">Emitting signals across thread boundaries</h4>
<div class="paragraph">
<p>Synapse can be used to implement interthread communication using signals. The data structures created by <a href="#connect"><code>connect</code></a> (or <a href="#translate"><code>translate</code></a>) use thread-local storage, so by default calling <a href="#emit"><code>emit</code></a> will call only functions connected by the calling thread (and will not return until all such functions have been called in order, or one of them throws.)</p>
</div>
<div class="paragraph">
<p>The following diagram shows the connections created (by calls to <code><a href="#connect">connect</a>&lt;S&gt;</code>) in a single thread for a given signal type <code>S</code>, each connecting an emitter to a function. When <code><a href="#emit">emit</a>&lt;S&gt;(e1,arg,&#8230;&#8203;)</code> is called, all functions connected (for <code>S</code>) to the given emitter <code>e1</code> are called (in the order in which the connections were created):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="fig1.png" alt="fig1">
</div>
</div>
<div class="paragraph">
<p>It is also possible for any thread to request to receive all signals emitted by other threads, by creating its own <a href="#thread_local_queue"><code>thread_local_queue</code></a> object using <a href="#create_thread_local_queue"><code>create_thread_local_queue</code></a>.</p>
</div>
<div class="paragraph">
<p>In this case, <em>in addition</em> to the behavior described above, <code><a href="#emit">emit</a>&lt;S&gt;(e1,arg,&#8230;&#8203;)</code> will capture its arguments (depending on the signature of <code>S</code>) and queue them into the <a href="#thread_local_queue"><code>thread_local_queue</code></a> object created by any thread <em>other</em> than the calling thread. Each such thread must poll its own <a href="#thread_local_queue"><code>thread_local_queue</code></a> regularly; this "emits" the queued objects locally and removes them from the queue (note that <a href="#poll"><code>poll</code></a> is not given an emitter or a signal type, it emits locally all queued objects, regardless of signal type or emitter).</p>
</div>
<div class="paragraph">
<p>This is illustrated by the following diagram:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="fig2.png" alt="fig2">
</div>
</div>
<div class="paragraph">
<p>A typical use case for this system is to update user interface objects with data generated by one or multiple worker threads: the user interface objects themselves need not be thread-safe, because they will be updated only synchronously, at the time <a href="#poll"><code>poll</code></a> is called.</p>
</div>
<div class="paragraph">
<p>Special care must be taken to ensure that any objects referred to by arguments passed to <a href="#emit"><code>emit</code></a> will remain valid until the time all other threads have polled their <a href="#thread_local_queue"><code>thread_local_queue</code></a> objects. For example, the following code is incorrect in the presence of <code>thread_local_queue</code> objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> my_signal_(*my_signal)( <span class="predefined-type">int</span> * );

<span class="directive">void</span> emit_my_signal( <span class="directive">void</span> * emitter, <span class="predefined-type">int</span> x ) {
    emit&lt;my_signal&gt;(emitter,&amp;x); <span class="comment">//Undefined behavior in the presence of thread_local_queues!</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem is that the address of <code>x</code> may be queued into other threads' queues, and since <code>x</code> is local to <code>emit_my_signal</code>, it may be destroyed by the time these threads call <a href="#poll"><code>poll</code></a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_scheduling_function_calls_across_thread_boundaries">Scheduling function calls across thread boundaries</h4>
<div class="paragraph">
<p>The <a href="#post"><code>post</code></a> function can be used to queue into a <a href="#thread_local_queue"><code>thread_local_queue</code></a> arbitrary functions for execution at the time <a href="#poll"><code>poll</code></a> is called. This feature allows critical worker threads to minimize the amount of time they consume by offloading expensive non-critical computations to another, non-critical thread. This also removes the need for synchronization, since the queued functions are executed synchronously in the thread that owns the <a href="#thread_local_queue"><code>thread_local_queue</code></a> object.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_building">Building</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Synapse has been formatted to be submitted for a Boost review, so its directory structure follows the common directory structure for Boost librariesand it&#8217;s built with Boost Build.</p>
</div>
<div class="paragraph">
<p>Alternatively, just put <code>connect.cpp</code> and either <code>thread_local_queue.cpp</code> or <code>interthread_stub.cpp</code> into your favorite build system, depending on whether or not your program calls <code>create_thread_local_queue</code>. If your program calls the <code>block</code> function, you also need to compile and link <code>block.cpp</code>.</p>
</div>
<div class="paragraph">
<p>However, note that if your program only emits signals (that is, it calls emit but it never creates any connections), there is no need to link any .cpp files; that is, <code>boost/synapse/emit.hpp</code> by itself is an independent header-only library. This way low level libraries that emit signals do not require the user to link Synapse, unless he cares to connect them.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_portability">Portability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Synapse requires compiler support for the following C++11 features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>thread-safe dynamic initialization of local static objects;</p>
</li>
<li>
<p><code>thread_local</code> objects;</p>
</li>
<li>
<p>lambda functions</p>
</li>
<li>
<p><code>&lt;thread&gt;</code></p>
</li>
<li>
<p><code>&lt;atomic&gt;</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_synopsis">Synopsis</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/emit.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span><span class="error">.</span>.. A&gt;
    <span class="predefined-type">int</span> emit( <span class="directive">void</span> <span class="directive">const</span> *, A... );

} }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/connect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">connection</span>;

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    shared_ptr&lt;connection&gt; connect( Emitter * e, F f );

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">Receiver</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    shared_ptr&lt;connection&gt; connect( Emitter * e, Receiver * r, F f );

    <span class="keyword">class</span> <span class="class">pconnection</span>;

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    weak_ptr&lt;pconnection&gt; connect( &lt;&lt;Emitter&gt;&gt; e, F f ); <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">Receiver</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    weak_ptr&lt;pconnection&gt; connect( &lt;&lt;Emitter&gt;&gt; e, &lt;&lt;Receiver&gt;&gt; r, F f ); <i class="conum" data-value="2"></i><b>(2)</b>

    shared_ptr&lt;connection <span class="directive">const</span>&gt; release( weak_ptr&lt;pconnection <span class="directive">const</span>&gt; <span class="directive">const</span> &amp; c );
    shared_ptr&lt;connection&gt; release( weak_ptr&lt;pconnection&gt; <span class="directive">const</span> &amp; c );

    <span class="keyword">namespace</span> meta {

        weak_ptr&lt;<span class="directive">void</span> <span class="directive">const</span>&gt; emitter();

        <span class="keyword">namespace</span> connect_flags {

            <span class="predefined-type">unsigned</span> <span class="directive">const</span> connecting=<span class="integer">1</span>;
            <span class="predefined-type">unsigned</span> <span class="directive">const</span> first_for_this_emitter=<span class="integer">2</span>;
            <span class="predefined-type">unsigned</span> <span class="directive">const</span> last_for_this_emitter=<span class="integer">4</span>;

        }

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>&gt;
        <span class="keyword">struct</span> connected {
            <span class="keyword">typedef</span> connected&lt;Signal&gt;(*type)( connection &amp; c, <span class="predefined-type">unsigned</span> connect_flags cf );
        };
    }

} }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>&lt;&lt;Emitter&gt;&gt;</code>  is <code>weak_ptr&lt;Emitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;Emitter&gt; const &amp;</code>;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>&lt;&lt;Emitter&gt;&gt;</code>  is <code>Emitter *</code>, <code>weak_ptr&lt;Emitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;Emitter&gt; const &amp;</code>; at least one of <code>e</code> and <code>r</code> is <em>not</em> a raw pointer.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/translate.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">template</span> &lt;
        <span class="keyword">class</span> <span class="class">OriginalSignal</span>,  <span class="keyword">class</span> <span class="class">TranslatedSignal</span>,
        <span class="keyword">class</span> <span class="class">OriginalEmitter</span>, <span class="keyword">class</span> <span class="class">TranslatedEmitter</span>&gt;
    shared_ptr&lt;connection&gt; translate( OriginalEmitter * e1, TranslatedEmitter * e2 );

    <span class="keyword">template</span> &lt;
        <span class="keyword">class</span> <span class="class">OriginalSignal</span>,  <span class="keyword">class</span> <span class="class">TranslatedSignal</span>,
        <span class="keyword">class</span> <span class="class">OriginalEmitter</span>, <span class="keyword">class</span> <span class="class">TranslatedEmitter</span>&gt;
    weak_ptr&lt;pconnection&gt; translate( &lt;&lt;OriginalEmitter&gt;&gt; e1, &lt;&lt;TranslatedEmitter&gt;&gt; e2 ); <i class="conum" data-value="1"></i><b>(1)</b>

} }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>&lt;&lt;OriginalEmitter&gt;&gt;</code> is either <code>OriginalEmitter *</code>, <code>weak_ptr&lt;OriginalEmitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;OriginalEmitter&gt; const &amp;</code>; <code>&lt;&lt;TranslatedEmitter&gt;&gt;</code> by analogy. At least one of <code>e1</code> and <code>e2</code> is <em>not</em> a raw pointer.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/connection.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">connection</span> { <span class="comment">//abstract base</span>

    <span class="directive">protected</span>:

        connection();
        ~connection();

    <span class="directive">public</span>:

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        <span class="directive">void</span> set_user_data( T <span class="directive">const</span> &amp; );

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        T * get_user_data() <span class="directive">const</span>;

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        shared_ptr&lt;T&gt; emitter() <span class="directive">const</span>;

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        shared_ptr&lt;T&gt; receiver() <span class="directive">const</span>;
    };

    <span class="keyword">class</span> <span class="class">pconnection</span>: <span class="directive">protected</span> connection { <span class="comment">//abstract base</span>

    <span class="directive">protected</span>:

        pconnection();
        ~pconnection();

    <span class="directive">public</span>:

        <span class="directive">using</span> connection::set_user_data;
        <span class="directive">using</span> connection::get_user_data;
        <span class="directive">using</span> connection::emitter;
        <span class="directive">using</span> connection::receiver;

    };

} }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/block.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">blocker</span>;

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>&gt;
    shared_ptr&lt;blocker&gt; block( &lt;&lt;Emitter&gt;&gt; e ); <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="keyword">namespace</span> meta {

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>&gt;
        <span class="keyword">struct</span> blocked {
            <span class="keyword">typedef</span> blocked&lt;Signal&gt;(*type)( blocker &amp;, <span class="predefined-type">bool</span> is_blocked );
        };

    }

} }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>&lt;&lt;Emitter&gt;&gt;</code>  is <code>Emitter *</code>, <code>weak_ptr&lt;Emitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;Emitter&gt; const &amp;</code>.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/blocker.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">blocker</span> { <span class="comment">//abstract base</span>

    <span class="directive">protected</span>:

        blocker();
        ~blocker();

    <span class="directive">public</span>:

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        shared_ptr&lt;T&gt; emitter() <span class="directive">const</span>;
    };

} }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/thread_local_queue.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">struct</span> thread_local_queue;
    shared_ptr&lt;thread_local_queue&gt; create_thread_local_queue();

    <span class="predefined-type">int</span> poll( thread_local_queue &amp; );
    <span class="predefined-type">int</span> wait( thread_local_queue &amp; );
    <span class="directive">void</span> post( thread_local_queue &amp;, function&lt;<span class="directive">void</span>()&gt; <span class="directive">const</span> &amp; );

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reference">Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="emit"><code>emit</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/emit.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span><span class="error">.</span>.. A&gt;
    <span class="predefined-type">int</span> emit( <span class="directive">void</span> <span class="directive">const</span> * e, A... );

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Calls all function objects that are connected to the specified <code>Signal</code> from the emitter <code>e</code>, in the order in which they were connected by <a href="#connect"><code>connect</code></a> or <a href="#translate"><code>translate</code></a>, passing the specified arguments depending on the <code>Signal</code> signature, subject to the connection lifetime/blocking restrictions.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The count of the connected function objects that were called. Signals that are currently blocked are not included in the count returned by <code>emit</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
It is the responsibility of the caller to ensure that the emitter object e does not expire before <code>emit</code> returns, otherwise the behavior is undefined.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Throws: </dt>
<dd>
<p>Any exception emitted by one of the connected function objects, in which case the remaining function objects are not called.</p>
</dd>
<dt class="hdlist1">Notes: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Values returned by the connected function objects are ignored.</p>
</li>
<li>
<p>If before <code>emit</code> returns <a href="#connect"><code>connect</code></a> is called on the same signal and the same emitter, any newly connected functions are not called during the same <code>emit</code>.</p>
</li>
<li>
<p>If before <code>emit</code> returns a <a href="#connection"><code>connection</code></a> object expires, it may or may not get called during the same <code>emit</code>.</p>
</li>
<li>
<p>If <code>e</code> is <code>0</code>, <code>emit</code> simply returns <code>0</code> without calling any functions. Because of this feature, if the emitter is held by a <code>shared_ptr</code> object <code>sp</code>, there is no harm in calling <code>emit&lt;Signal&gt;(sp.get(),&#8230;&#8203;)</code> even if <code>sp</code> is empty. Similarly, if the caller holds a <code>weak_ptr</code> to the emitter object which has expired, calling <code>emit&lt;Signal&gt;(wp.lock().get(),&#8230;&#8203;)</code> will simply return <code>0</code>.</p>
</li>
<li>
<p><code>emit</code> takes its arguments by value. Use <code>boost::ref</code> to pass by reference.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Thread safety: </dt>
<dd>
<p>By default <code>emit</code> will only call functions connected from the calling thread. In addition, the signal is pushed onto any <a href="#thread_local_queue"><code>thread_local_queue</code></a> objects created in other threads, but only if those threads currently have at least one active connection for the specified <code>Signal</code>. In this case <code>emit</code> captures its arguments similarly to <code>std::bind</code>, and it is the responsibility of the caller to ensure that they remain valid until the posted signal is processed in all other threads, by a call to <a href="#poll"><code>thread_local_queue::poll</code></a> or <a href="#wait"><code>thread_local_queue::wait</code></a>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="connect"><code>connect</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/connect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">connection</span>;

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    shared_ptr&lt;connection&gt; connect( Emitter * e, F f );

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">Receiver</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    shared_ptr&lt;connection&gt; connect( Emitter * e, Receiver * r, F f );

    <span class="keyword">class</span> <span class="class">pconnection</span>;

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    weak_ptr&lt;pconnection&gt; connect( &lt;&lt;Emitter&gt;&gt; e, F f ); <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">Receiver</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    weak_ptr&lt;pconnection&gt; connect( &lt;&lt;Emitter&gt;&gt; e, &lt;&lt;Receiver&gt;&gt; r, F f ); <i class="conum" data-value="2"></i><b>(2)</b>

} }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>&lt;&lt;Emitter&gt;&gt;</code>  is <code>weak_ptr&lt;Emitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;Emitter&gt; const &amp;</code>;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>&lt;&lt;Emitter&gt;&gt;</code>  is <code>Emitter *</code>, <code>weak_ptr&lt;Emitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;Emitter&gt; const &amp;</code>; at least one of <code>e</code> and <code>r</code> is <em>not</em> a raw pointer.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Overloads of <code>connect</code> that return <code>shared_ptr&lt;<a href="#connection">connection</a>&gt;</code> create connections whose lifetime is explicitly managed by the user. Such connections require that the caller keeps the returned <a href="#connection"><code>connection</code></a> object afloat for as long as the connection should persist.</p>
</div>
<div class="paragraph">
<p>Overloads of <code>connect</code> that return <code>weak_ptr&lt;<a href="#pconnection">pconnection</a>&gt;</code> take at least one of <code>e</code> and <code>r</code> as a <code>weak_ptr</code> or <code>shared_ptr</code>. They create <em>persistent</em> connections which expire when either <code>e</code> or <code>r</code> expire.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Connects the specified <code>Signal</code> from the emitter <code>e</code> to the function object <code>f</code>. The arguments of <code>F</code> must match the arguments of <code>Signal</code>, except that if <code>r</code> is specified, it is dereferenced and prepended as the first argument to <code>F</code>, followed by the rest of the arguments as specified by the <code>Signal</code> signature. The signal is considered disconnected when either of the following occurs:</p>
<div class="ulist">
<ul>
<li>
<p>The returned <code>shared_ptr&lt;<a href="#connection">connection</a>&gt;</code> object expires (this applies only to overloads that return <code>shared_ptr&lt;<a href="#connection">connection</a>&gt;</code>);</p>
</li>
<li>
<p><code>e</code> (passed as either <code>weak_ptr&lt;Emitter&gt;</code> or <code>shared_ptr&lt;Emitter&gt;</code>) expires;</p>
</li>
<li>
<p><code>r</code> (passed as either <code>weak_ptr&lt;Emitter&gt;</code> or <code>shared_ptr&lt;Emitter&gt;</code>) expires.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The returned object does not assume ownership of <code>e</code> or <code>r</code>: passing <code>shared_ptr</code> is equivalent to passing <code>weak_ptr</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If either the emitter or the receiver, passed as raw pointers, expire before the returned <a href="#connection"><code>connection</code></a> object has expired, the behavior is undefined.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><a id="meta::connected"></a> The <code>meta::emitter</code> emits the <code>meta::connected&lt;Signal&gt;</code> signal:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">namespace</span> meta {

        weak_ptr&lt;<span class="directive">void</span> <span class="directive">const</span>&gt; emitter();

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>&gt;
        <span class="keyword">struct</span> connected {
            <span class="comment">//unspecified</span>
        };

        <span class="keyword">namespace</span> connect_flags {
            <span class="predefined-type">unsigned</span> <span class="directive">const</span> connecting=<span class="integer">1</span>;
            <span class="predefined-type">unsigned</span> <span class="directive">const</span> first_for_this_emitter=<span class="integer">2</span>;
            <span class="predefined-type">unsigned</span> <span class="directive">const</span> last_for_this_emitter=<span class="integer">4</span>;
        }

    }

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>meta::connected&lt;Signal&gt;</code> signal is also emitted when the returned object expires. Handlers of the meta signal take a mutable reference to the <a href="#connection"><code>connection</code></a> object being created or destroyed, and a second <code>unsigned</code> argument, <code>flags</code>, which indicates the circumstances under which the meta signal is emitted:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the <a href="#connection"><code>connection</code></a> object is being created, the <code>connecting</code> bit is set, otherwise it is clear;</p>
</li>
<li>
<p>If this is the first <code>Signal</code> connection being created for the emitter <code>e</code>, the <code>first_for_this_emitter</code> bit is set, otherwise it is clear;</p>
</li>
<li>
<p>If this is the last <code>Signal</code> connection being destroyed for the emitter <code>e</code>, the <code>last_for_this_emitter</code> bit is set, otherwise it is clear.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because class <a href="#connection"><code>connection</code></a> is the protected base of class <a href="#pconnection"><code>pconnection</code></a>, handlers of <code>meta::connected&lt;Signal&gt;</code> take <code>connection &amp;</code> regardless of which <code>connect</code> overload was used.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The passed <a href="#connection"><code>connection</code></a> object can be used to access the emitter and receiver objects passed to <code>connect</code>.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Thread safety: </dt>
<dd>
<p>Please see <a href="#emit"><code>emit</code></a> and <a href="#thread_local_queue"><code>thread_local_queue</code></a>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="translate"><code>translate</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/translate.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">template</span> &lt;
        <span class="keyword">class</span> <span class="class">OriginalSignal</span>,  <span class="keyword">class</span> <span class="class">TranslatedSignal</span>,
        <span class="keyword">class</span> <span class="class">OriginalEmitter</span>, <span class="keyword">class</span> <span class="class">TranslatedEmitter</span>&gt;
    shared_ptr&lt;connection&gt; translate( OriginalEmitter * e1, TranslatedEmitter * e2 );

    <span class="keyword">template</span> &lt;
        <span class="keyword">class</span> <span class="class">OriginalSignal</span>,  <span class="keyword">class</span> <span class="class">TranslatedSignal</span>,
        <span class="keyword">class</span> <span class="class">OriginalEmitter</span>, <span class="keyword">class</span> <span class="class">TranslatedEmitter</span>&gt;
    weak_ptr&lt;pconnection&gt; translate( &lt;&lt;OriginalEmitter&gt;&gt; e1, &lt;&lt;TranslatedEmitter&gt;&gt; e2 ); <i class="conum" data-value="1"></i><b>(1)</b>

} }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>&lt;&lt;OriginalEmitter&gt;&gt;</code> is either <code>OriginalEmitter *</code>, <code>weak_ptr&lt;OriginalEmitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;OriginalEmitter&gt; const &amp;</code>; <code>&lt;&lt;TranslatedEmitter&gt;&gt;</code> by analogy. At least one of <code>e1</code> and <code>e2</code> is <em>not</em> a raw pointer.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>The <code>translate</code> function template creates a connection which causes the emitter <code>e2</code> to emit <code>TranslatedSignal</code> each time the emitter <code>e1</code> emits <code>OriginalSignal</code> (the two signals must have campatible signatures). This behavior persists until:</p>
<div class="ulist">
<ul>
<li>
<p>the returned <a href="#connection"><code>connection</code></a> object expires (this applies only to the <code>translate</code> overload that takes <code>e1</code> and <code>e2</code> as raw pointers);</p>
</li>
<li>
<p><code>e1</code> (passed as either <code>weak_ptr</code> or <code>shared_ptr</code> expires;</p>
</li>
<li>
<p><code>e2</code> (passed as either <code>weak_ptr</code> or <code>shared_ptr</code> expires.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The returned <a href="#connection"><code>connection</code></a> object does not assume ownership of <code>e1</code> or <code>e2</code>: passing <code>shared_ptr</code> is equivalent to passing <code>weak_ptr</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If either <code>e1</code> or <code>e2</code>, passed as raw pointers, expire before the returned <a href="#connection"><code>connection</code></a> object has expired, the behavior is undefined.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="connection"><code>connection</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/connection.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">connection</span> { <span class="comment">//abstract base</span>

    <span class="directive">protected</span>:

        connection();
        ~connection();

    <span class="directive">public</span>:

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        <span class="directive">void</span> set_user_data( T <span class="directive">const</span> &amp; );

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        T * get_user_data() <span class="directive">const</span>;

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        shared_ptr&lt;T&gt; emitter() <span class="directive">const</span>;

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        shared_ptr&lt;T&gt; receiver() <span class="directive">const</span>;
    };

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <a href="#connect"><code>connect</code></a> and <a href="#translate"><code>translate</code></a> functions return <code>shared_ptr&lt;connection&gt;</code> that is used to control the lifetime of the connection. As well, <code>connection</code> objects are passed to handlers of the <a href="#meta::connected"><code>meta::connected</code></a> signal, which can use the <a href="#connection::emitter"><code>emitter</code></a> member function template to access the emitter object passed to <a href="#connect"><code>connect</code></a>/<a href="#translate"><code>translate</code></a>, and the <a href="#connection::set_user_data"><code>set_user_data</code></a>/<a href="#connection::get_user_data"><code>get_user_data</code></a> member function templates to store auxiliary information in the <code>connection</code> object.</p>
</div>
<hr>
<div class="sect3">
<h4 id="connection::set_user_data"><code>set_user_data</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
<span class="directive">void</span> set_user_data( shared_ptr&lt;T&gt; <span class="directive">const</span> &amp; data );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Description: </dt>
<dd>
<p>Stores a copy of data into this. Use <code>get_user_data</code> to access it.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="connection::get_user_data"><code>get_user_data</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
T * get_user_data() <span class="directive">const</span>;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If this contains object of type T previously copied by a call to connection::set_user_data, returns a pointer to the copy.</p>
</li>
<li>
<p>If connection::set_user_data has not been called for this, or if the type used to instantiate the connection::set_user_data function template doesn&#8217;t match the type used with connection::get_user_data, returns 0.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="connection::emitter"><code>emitter</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
shared_ptr&lt;T&gt; emitter() <span class="directive">const</span>;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A shared_ptr that points the emitter that was passed to an overload of the connect (or translate) function template to get the connection object.</p>
</dd>
<dt class="hdlist1">Notes: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>An empty <code>shared_ptr</code> is returned if:</p>
<div class="ulist">
<ul>
<li>
<p><code>T</code> does not match the static type of the emitter passed to <code>connect</code> (or <code>translate</code>), or</p>
</li>
<li>
<p>the emitter was passed to <code>connect</code> (or <code>translate</code>) as a <code>shared_ptr</code>/<code>weak_ptr</code> and it has expired.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the emitter was passed to <code>connect</code> (or <code>translate</code>) as a raw pointer, the returned <code>shared_ptr</code> points that emitter but does not (can not) keep it afloat.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="connection::receiver"><code>receiver</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
shared_ptr&lt;T&gt; receiver() <span class="directive">const</span>;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A <code>shared_ptr</code> that points the receiver that was passed to an overload of the <code>connect</code> (or <code>translate</code>) function template to get the <code>connection</code> object.</p>
</dd>
<dt class="hdlist1">Notes: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>An empty <code>shared_ptr</code> is returned if:</p>
<div class="ulist">
<ul>
<li>
<p>No receiver object was passed to <code>connect</code> (or <code>translate</code>), or</p>
</li>
<li>
<p><code>T</code> does not match the static type of the receiver passed to <code>connect</code> (or <code>translate</code>), or</p>
</li>
<li>
<p>the emitter was passed to <code>connect</code> (or <code>translate</code>) as a <code>shared_ptr</code>/<code>weak_ptr</code> and it has expired.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the emitter was passed to <code>connect</code> (or <code>translate</code>) as a raw pointer, the returned <code>shared_ptr</code> points that emitter but does not (can not) keep it afloat.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="pconnection"><code>pconnection</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/connection.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">pconnection</span>: <span class="directive">protected</span> connection { <span class="comment">//abstract base</span>

    <span class="directive">protected</span>:

        pconnection();
        ~pconnection();

    <span class="directive">public</span>:

        <span class="directive">using</span> connection::set_user_data;
        <span class="directive">using</span> connection::get_user_data;
        <span class="directive">using</span> connection::emitter;
        <span class="directive">using</span> connection::receiver;

    };

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>pconnection</code> class represents <em>persistent</em> connections, returned by overloads of <a href="#connect"><code>connect</code></a> and <a href="#translate"><code>translate</code></a> which take at least one <code>weak_ptr</code> or <code>shared_ptr</code> argument. The user is not required to keep the returned <code>weak_ptr&lt;pconnection&gt;</code> afloat: the connection will be destroyed automatically when Synapse detects that either the emitter or the receiver argument to <a href="#connect"><code>connect</code></a> have expired.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use <a href="#release"><code>release</code></a> to convert a non-owning <code>weak_ptr&lt;pconnection&gt;</code> reference to an owning <code>shared_ptr&lt;<a href="#connection">connection</a>&gt;</code> reference.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="block"><code>block</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/block.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">blocker</span>;

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>&gt;
    shared_ptr&lt;blocker&gt; block( &lt;&lt;Emitter&gt;&gt; e ); <i class="conum" data-value="1"></i><b>(1)</b>

} }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>&lt;&lt;Emitter&gt;&gt;</code> is either <code>Emitter *</code>, <code>weak_ptr&lt;Emitter&gt;</code> or, equivalently, <code>shared_ptr&lt;Emitter&gt;</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Blocks the specified <code>Signal</code> from the emitter <code>e</code> until the returned <code>blocker</code> object expires. While the <code>Signal</code> is blocked, calls to <code>emit&lt;Signal&gt;</code> for <code>e</code> are ignored and return <code>0</code>. The returned <code>blocker</code> object does not own <code>e</code> even if the <code>shared_ptr</code> <code>block</code> overload is used.</p>
</li>
<li>
<p><a id="meta::blocked"></a> The <code>meta::emitter</code> emits the <code>meta::blocked&lt;Signal&gt;</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse { <span class="keyword">namespace</span> meta {

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>&gt;
    <span class="keyword">struct</span> blocked {
        <span class="comment">//unspecified</span>
    };

} } }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>meta::blocked&lt;Signal&gt;</code> signal is also emitted when the returned <a href="#blocker"><code>blocker</code></a> object expires. Handlers of the meta signal take a reference to the <a href="#blocker"><code>blocker</code></a> object being created or destroyed, and a second <code>bool</code> argument, <code>is_blocked</code>, which is true if the signal is becoming blocked, false if it is becoming unblocked.</p>
</div>
</li>
</ol>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Blocking affects existing as well as future connections.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If <code>block</code> is passed a raw pointer, deleting the emitter before the returned <code>blocker</code> object has expired results in undefined behavior.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="blocker"><code>blocker</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/blocker.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">blocker</span> { <span class="comment">//abstract base</span>

    <span class="directive">protected</span>:

        blocker();
        ~blocker();

    <span class="directive">public</span>:

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        shared_ptr&lt;T&gt; emitter() <span class="directive">const</span>;
    };

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <a href="#block"><code>block</code></a> function returns <code>shared_ptr&lt;blocker const&gt;</code> that is used to control the time the signal remains blocked. As well, <code>blocker</code> objects are passed to handlers of the <a href="#meta::blocked"><code>meta::blocked</code></a> signal, which can use the <code>emitter</code> member function template to access the emitter object passed to <a href="#block"><code>block</code></a>.</p>
</div>
<hr>
<div class="sect3">
<h4 id="blocker::emitter"><code>emitter</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
shared_ptr&lt;T&gt; emitter() <span class="directive">const</span>;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A <code>shared_ptr</code> that points the emitter that was passed to an overload of the <a href="#block"><code>block</code></a> function template to get the <code>blocker</code> object.</p>
</dd>
<dt class="hdlist1">Notes: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>An empty shared_ptr is returned if:</p>
<div class="ulist">
<ul>
<li>
<p><code>T</code> does not match the static type of the emitter passed to <a href="#block"><code>block</code></a>, or</p>
</li>
<li>
<p>the emitter was passed to <a href="#block"><code>block</code></a> as a <code>shared</code>/<code>weak_ptr</code> and it has expired.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the emitter was passed to <a href="#block"><code>block</code></a> as a raw pointer, the returned <code>shared_ptr</code> points that emitter but does not (can not) keep it afloat.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="thread_local_queue"><code>thread_local_queue</code></h3>
<div class="sect3">
<h4 id="create_thread_local_queue"><code>create_thread_local_queue</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/thread_local_queue.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">struct</span> thread_local_queue;
    shared_ptr&lt;thread_local_queue&gt; create_thread_local_queue();

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A thread-local object that can be used to queue signals emitted asynchronously from other threads. Use <a href="#poll"><code>poll</code></a> to emit the queued signals synchronously into the calling thread. See <a href="#_interthread_communication">Interthread communication</a>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While any number of threads can use this function to create their own <a href="#thread_local_queue"><code>thread_local_queue</code></a>, it is invalid to create more than one <code>thread_local_queue</code> object per thread.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="poll"><code>poll</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/thread_local_queue.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="predefined-type">int</span> poll( thread_local_queue &amp; );

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Synchronously emits all signals queued asynchronously into <code>q</code> by calls to <a href="#emit"><code>emit</code></a> from other threads. See <a href="#_interthread_communication">Interthread communication</a>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The total number of signals emitted.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="wait"><code>wait</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/thread_local_queue.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="predefined-type">int</span> wait( thread_local_queue &amp; );

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>The same as <code><a href="#poll">poll</a>(q)</code>, except that it blocks and does not return until at least one signal was delivered.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The total number of signals emitted (always greater than 1).</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="post"><code>post</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/thread_local_queue.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="directive">void</span> post( thread_local_queue &amp;, function&lt;<span class="directive">void</span>()&gt; <span class="directive">const</span> &amp; );

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Queues <code>f</code> to be called next time <code>q</code> is polled; that is, <code>f</code> will be executed synchronously in the thread that has created <code>q</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While <a href="#poll"><code>poll</code></a> (or <a href="#wait"><code>wait</code></a>) must be called from the thread that created the <a href="#thread_local_queue"><code>thread_local_queue</code></a> object, <a href="#post"><code>post</code></a> may be called from any thread.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_programming_techniques">Programming techniques</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_synapsifying_c_callbacks">Synapsifying C callbacks</h3>
<div class="paragraph">
<p>Synapse can be used with any C-style callback API to install C++ functions, including lambdas, as callbacks. For example, consider the <code>SSL_set_info_callback</code> from <a href="https://www.openssl.org/">OpenSSL</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="directive">void</span> SSL_set_info_callback(SSL *ssl,
        <span class="directive">void</span> (*cb) (<span class="directive">const</span> SSL *ssl, <span class="predefined-type">int</span> type, <span class="predefined-type">int</span> val));</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can define the following Synapse signal to represent this callback:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> SSL_info_callback_(*SSL_info_callback)( <span class="directive">const</span> SSL *ssl, <span class="predefined-type">int</span> type, <span class="predefined-type">int</span> val );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, at a global scope or during initialization, we install a handler for the <code>meta::connected&lt;SSL_info_callback&gt;</code> signal, which the <a href="#meta::connected"><code>meta::emitter</code></a> emits every time the user connects or disconnects the <code>SSL_info_callback</code> signal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="directive">void</span> emit_fwd( SSL <span class="directive">const</span> * ssl, <span class="predefined-type">int</span> type, <span class="predefined-type">int</span> val );

<span class="predefined-type">int</span> main( <span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> <span class="directive">const</span> * argv[ ] ) {

    connect&lt;meta::connected&lt;SSL_info_callback&gt; &gt;( meta::emitter(),
        [ ]( connection &amp; c, <span class="predefined-type">unsigned</span> flags ) { <i class="conum" data-value="1"></i><b>(1)</b>

            <span class="keyword">if</span>( flags&amp;meta::connect_flags::connecting ) { <i class="conum" data-value="2"></i><b>(2)</b>

                <span class="keyword">if</span>( flags&amp;meta::connect_flags::first_for_this_emitter ) <i class="conum" data-value="3"></i><b>(3)</b>
                    SSL_set_info_callback(c.emitter&lt;SSL&gt;().get(),&amp;emit_fwd); <i class="conum" data-value="4"></i><b>(4)</b>

            } <span class="keyword">else</span> { <i class="conum" data-value="5"></i><b>(5)</b>

                <span class="keyword">if</span>( flags&amp;meta::connect_flags::last_for_this_emitter ) <i class="conum" data-value="6"></i><b>(6)</b>
                    <span class="keyword">if</span>( <span class="directive">auto</span> ssl = c.emitter&lt;SSL&gt;() ) <i class="conum" data-value="7"></i><b>(7)</b>
                        SSL_set_info_callback(ssl.get(),<span class="integer">0</span>); <i class="conum" data-value="8"></i><b>(8)</b>

            }

        } );

}

<span class="directive">void</span> emit_fwd( SSL <span class="directive">const</span> * ssl, <span class="predefined-type">int</span> type, <span class="predefined-type">int</span> val ) {
    emit&lt;SSL_info_callback&gt;(ssl,ssl,type,val);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This lambda function is called every time the user connects or disconnects the <code>SSL_info_callback</code> Synapse signal.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The user is <em>connecting</em> the <code>SSL_info_callback</code> signal.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This is the <em>first</em> time the <code>SSL_info_callback</code> signal is being connected for a particular <code>SSL</code> object (emitter).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Use <a href="#connection::emitter"><code>connection::emitter</code></a> to get the emitter as a <code>shared_ptr&lt;SSL&gt;</code> (we know the emitter is of type <code>SSL *</code>), and use the OpenSSL API to install a C callback <code>emit_fwd</code>, which uses <code><a href="#emit">emit</a>&lt;SSL_info_callback&gt;</code> to call all connected Synapse functions.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The user is <em>disconnecting</em> the <code>SSL_info_callback</code> signal.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This is the <em>last</em> <code>SSL_info_callback</code> connection being destroyed for a particular <code>SSL</code> object (emitter).</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Check if the SSL object is still accessible (it may have been destroyed already).</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Uninstall the <code>emit_fwd</code> callback.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once this handler for the <code>meta::connected&lt;SSL_info_callback&gt;</code> signal is installed, we can simply use <a href="#connect"><code>connect</code></a> to install a C++ lamda handler for the <code>SSL_info_callback</code> signal we defined:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">shared_ptr&lt;SSL&gt; ssl(SSL_new(ctx),&amp;SSL_free);

connect&lt;SSL_info_callback&gt;( ssl,
    [ ]( <span class="directive">const</span> SSL *ssl, <span class="predefined-type">int</span> type, <span class="predefined-type">int</span> val ) noexcept {

    } );</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reporting_exceptions_from_code_noexcept_code_signal_handlers">Reporting exceptions from <code>noexcept</code> signal handlers</h3>
<div class="paragraph">
<p>Sometimes connected functions are not permitted to throw exceptions&#8201;&#8212;&#8201;this is usually the case when the callback originates in C code. With synapse, such exceptions can be reported safely to a C++ context that can store them for later processing.</p>
</div>
<div class="paragraph">
<p>First, we define a Synapse signal we will use to report exceptions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> exception_caught_(*exception_caught)();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we take a handler of the <code>SSL_info_callback</code> (see above) as an example, we could modify it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++">shared_ptr&lt;SSL&gt; ssl(SSL_new(ctx),&amp;SSL_free);

connect&lt;SSL_info_callback&gt;( ssl,
    [ ]( <span class="directive">const</span> SSL *ssl, <span class="predefined-type">int</span> type, <span class="predefined-type">int</span> val ) noexcept {
        <span class="keyword">try</span> {

            <span class="comment">//code which may throw</span>

        } <span class="keyword">catch</span>(...) {

            <span class="predefined-type">int</span> n=synapse::emit&lt;exception_caught&gt;(ssl); <i class="conum" data-value="1"></i><b>(1)</b>
            assert(n&gt;<span class="integer">0</span>); <i class="conum" data-value="2"></i><b>(2)</b>

        }
    } );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="#emit"><code>emit</code></a> the <code>exception_caught</code> Synapse signal from the <code>ssl</code> object. Handlers of this signal must be able to deal with any exception, for example they can use <code>std::current_exception</code> to capture the exception and rethrow it once control has exited the critical <code>noexcept</code> path.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="#emit"><code>emit</code></a> returns the number of connected functions it called, so this <code>assert</code> ensures that the exception won&#8217;t get ignored.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_using_synapse_with_qt_to_avoid_mocing">Using Synapse with Qt to avoid MOCing</h3>
<div class="paragraph">
<p>The signal programming API that is used in <a href="https://www.qt.io/">Qt</a> is intrusive: signals must be specified in the definition of each type. For this reason, it is not possible to add signals to existing Qt types. When this is needed, users are directed to define the new signals in their own class which derives from the Qt type they wanted to add signal(s) to.</p>
</div>
<div class="paragraph">
<p><a href="https://wiki.qt.io/Qt_for_Beginners#Creating_custom_signals_and_slots">There is a special example that illustrates this approach</a>. Unfortunately, this requires the use of the proprietary Qt Meta Object Compiler which the author finds cumbersome. Below is the same example modified to use Synapse signals, which requires no MOCing (the changes made to the original program are marked with numbers):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="preprocessor">#include</span> <span class="include">&lt;boost/synapse/connect.hpp&gt;</span>
<span class="preprocessor">#define</span> QT_NO_EMIT <span class="comment">//Suppress the #define emit from Qt since it clashes with synapse::emit.</span>
<span class="preprocessor">#include</span> <span class="include">&lt;QtWidgets/QApplication&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;QtWidgets/QPushButton&gt;</span>

<span class="keyword">namespace</span> synapse=boost::synapse;

<span class="keyword">class</span> <span class="class">Window</span> : <span class="directive">public</span> QWidget
{
<span class="directive">public</span>:
    <span class="directive">explicit</span> Window(QWidget *parent = <span class="integer">0</span>);
    <span class="label">signals:</span> <span class="comment">//Not needed with Synapse but okay</span>
    <span class="keyword">typedef</span> <span class="keyword">struct</span> counterReached_(*counterReached)(); <i class="conum" data-value="1"></i><b>(1)</b>
<span class="directive">private</span> slots: <span class="comment">//&lt;-- Not needed with Synapse but okay</span>
    <span class="directive">void</span> slotButtonClicked(<span class="predefined-type">bool</span> checked);
<span class="directive">private</span>:
    <span class="predefined-type">int</span> m_counter;
    QPushButton *m_button;
    shared_ptr&lt;synapse::connection&gt; c_; <i class="conum" data-value="2"></i><b>(2)</b>
};

Window::Window(QWidget *parent) :
    QWidget(parent)
{
     <span class="comment">// Set size of the window</span>
     setFixedSize(<span class="integer">100</span>, <span class="integer">50</span>);

    <span class="comment">// Create and position the button</span>
    m_button = <span class="keyword">new</span> QPushButton(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>, <span class="local-variable">this</span>);
    m_button-&gt;setGeometry(<span class="integer">10</span>, <span class="integer">10</span>, <span class="integer">80</span>, <span class="integer">30</span>);
    m_button-&gt;setCheckable(<span class="predefined-constant">true</span>);

    <span class="comment">// Set the counter to 0</span>
    m_counter = <span class="integer">0</span>;

    connect(m_button, SIGNAL (clicked(<span class="predefined-type">bool</span>)), <span class="local-variable">this</span>, SLOT (slotButtonClicked(<span class="predefined-type">bool</span>)));

    c_=synapse::connect&lt;counterReached&gt;(<span class="local-variable">this</span>,&amp;QApplication::quit); <i class="conum" data-value="3"></i><b>(3)</b>
}

<span class="directive">void</span> Window::slotButtonClicked(<span class="predefined-type">bool</span> checked)
{
    <span class="keyword">if</span> (checked)
        m_button-&gt;setText(<span class="string"><span class="delimiter">&quot;</span><span class="content">Checked</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">else</span>
        m_button-&gt;setText(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>);
    m_counter ++;
    <span class="keyword">if</span> (m_counter == <span class="integer">10</span>)
        synapse::emit&lt;counterReached&gt;(<span class="local-variable">this</span>); <i class="conum" data-value="4"></i><b>(4)</b>
}

<span class="predefined-type">int</span> main(<span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> **argv)
{
    QApplication app (argc, argv);

    Window window;
    window.show();

    <span class="keyword">return</span> app.exec();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Was: <code>void counterReached();</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Needed to keep the Synapse connection afloat.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Was: <code>connect(this, SIGNAL (counterReached()), QApplication::instance(), SLOT (quit()));</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Was: <code>emit counterReached();</code></td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples">Examples</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_glfw">GLFW</h3>
<div class="paragraph">
<p><a href="http://www.glfw.org/">GLFW</a> is an Open Source, multi-platform library for OpenGL, OpenGL ES and Vulkan development on the desktop. It provides a simple API for creating windows, contexts and surfaces, receiving input and events.</p>
</div>
<div class="paragraph">
<p>Synapse can be used to enhance GLFW event handling. Below is one of the GLFW example programs which draws a spinning OpenGL triangle, modified to use Synapse to handle the <code>Esc</code> key, which closes the window and exits. The changes to the original program are marked with <code>&lt;SYNAPSE&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/block.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c++"><span class="comment">//========================================================================</span>
<span class="comment">// Simple GLFW example</span>
<span class="comment">// Copyright (c) Camilla Lwy &lt;elmindreda@glfw.org&gt;</span>
<span class="comment">//</span>
<span class="comment">// This software is provided 'as-is', without any express or implied</span>
<span class="comment">// warranty. In no event will the authors be held liable for any damages</span>
<span class="comment">// arising from the use of this software.</span>
<span class="comment">//</span>
<span class="comment">// Permission is granted to anyone to use this software for any purpose,</span>
<span class="comment">// including commercial applications, and to alter it and redistribute it</span>
<span class="comment">// freely, subject to the following restrictions:</span>
<span class="comment">//</span>
<span class="comment">// 1. The origin of this software must not be misrepresented; you must not</span>
<span class="comment">//    claim that you wrote the original software. If you use this software</span>
<span class="comment">//    in a product, an acknowledgment in the product documentation would</span>
<span class="comment">//    be appreciated but is not required.</span>
<span class="comment">//</span>
<span class="comment">// 2. Altered source versions must be plainly marked as such, and must not</span>
<span class="comment">//    be misrepresented as being the original software.</span>
<span class="comment">//</span>
<span class="comment">// 3. This notice may not be removed or altered from any source</span>
<span class="comment">//    distribution.</span>
<span class="comment">//</span>
<span class="comment">//========================================================================</span>
<span class="comment">//! [code]</span>

<span class="preprocessor">#include</span> <span class="include">&lt;glad/glad.h&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;GLFW/glfw3.h&gt;</span>

<span class="preprocessor">#include</span> <span class="include">&quot;linmath.h&quot;</span>

<span class="preprocessor">#include</span> <span class="include">&lt;stdlib.h&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;stdio.h&gt;</span>

<span class="comment">//&lt;SYNAPSE&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&quot;synapsify_glfw.hpp&quot;</span> <span class="comment">//See next listing</span>
<span class="preprocessor">#include</span> <span class="include">&lt;boost/synapse/connect.hpp&gt;</span>
<span class="keyword">namespace</span> synapse = boost::synapse;
<span class="comment">//&lt;/SYNAPSE&gt;</span>

<span class="directive">static</span> <span class="directive">const</span> <span class="keyword">struct</span>
{
    <span class="predefined-type">float</span> x, y;
    <span class="predefined-type">float</span> r, g, b;
} vertices[<span class="integer">3</span>] =
{
    { -<span class="float">0</span><span class="float">.6f</span>, -<span class="float">0</span><span class="float">.4f</span>, <span class="float">1</span>.f, <span class="float">0</span>.f, <span class="float">0</span>.f },
    {  <span class="float">0</span><span class="float">.6f</span>, -<span class="float">0</span><span class="float">.4f</span>, <span class="float">0</span>.f, <span class="float">1</span>.f, <span class="float">0</span>.f },
    {   <span class="float">0</span>.f,  <span class="float">0</span><span class="float">.6f</span>, <span class="float">0</span>.f, <span class="float">0</span>.f, <span class="float">1</span>.f }
};

<span class="directive">static</span> <span class="directive">const</span> <span class="predefined-type">char</span>* vertex_shader_text =
<span class="string"><span class="delimiter">&quot;</span><span class="content">#version 110</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">uniform mat4 MVP;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">attribute vec3 vCol;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">attribute vec2 vPos;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">varying vec3 color;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">void main()</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">{</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">    gl_Position = MVP * vec4(vPos, 0.0, 1.0);</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">    color = vCol;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">}</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;

<span class="directive">static</span> <span class="directive">const</span> <span class="predefined-type">char</span>* fragment_shader_text =
<span class="string"><span class="delimiter">&quot;</span><span class="content">#version 110</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">varying vec3 color;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">void main()</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">{</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">    gl_FragColor = vec4(color, 1.0);</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">}</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;

<span class="directive">static</span> <span class="directive">void</span> error_callback(<span class="predefined-type">int</span> error, <span class="directive">const</span> <span class="predefined-type">char</span>* description)
{
    fprintf(stderr, <span class="string"><span class="delimiter">&quot;</span><span class="content">Error: %s</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, description);
}

<span class="comment">//&lt;SYNAPSE&gt;</span>
<span class="comment">//Synapse allows this function (present in the original example) to be implemented as</span>
<span class="comment">//a lambda, so we don't need it here.</span>

<span class="comment">//static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)</span>
<span class="comment">//{</span>
<span class="comment">//    if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)</span>
<span class="comment">//        glfwSetWindowShouldClose(window, GLFW_TRUE);</span>
<span class="comment">//}</span>
<span class="comment">//&lt;/SYNAPSE&gt;</span>

<span class="predefined-type">int</span> main(<span class="directive">void</span>)
{
    <span class="comment">//&lt;SYNAPSE&gt;</span>
    <span class="comment">//See the next listing: this function installs the Synapse meta signal handlers.</span>
    synapsify_glfw();
    <span class="comment">//&lt;/SYNAPSE&gt;</span>

    GLFWwindow* window;
    GLuint vertex_buffer, vertex_shader, fragment_shader, program;
    GLint mvp_location, vpos_location, vcol_location;

    glfwSetErrorCallback(error_callback);

    <span class="keyword">if</span> (!glfwInit())
        exit(EXIT_FAILURE);

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="integer">2</span>);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="integer">0</span>);

    window = glfwCreateWindow(<span class="integer">640</span>, <span class="integer">480</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Simple example</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">NULL</span>, <span class="predefined-constant">NULL</span>);
    <span class="keyword">if</span> (!window)
    {
        glfwTerminate();
        exit(EXIT_FAILURE);
    }

    <span class="comment">//&lt;SYNAPSE&gt;</span>
    <span class="comment">//Here we connect the glfw_signals::key signal to a lambda function, instead of the static key_callback</span>
    <span class="comment">//used in the original example (look up above the main function).</span>
    <span class="directive">auto</span> connected = synapse::connect&lt;glfw_signals::key&gt;(window,
        [ ]( GLFWwindow * window, <span class="predefined-type">int</span> key, <span class="predefined-type">int</span> <span class="comment">/*scancode*/</span>, <span class="predefined-type">int</span> action, <span class="predefined-type">int</span> <span class="comment">/*mods*/</span> )
        {
            <span class="keyword">if</span> (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)
                glfwSetWindowShouldClose(window, GLFW_TRUE);
        } );
    glfwSetKeyCallback(window, key_callback);

    glfwMakeContextCurrent(window);
    gladLoadGLLoader((GLADloadproc) glfwGetProcAddress);
    glfwSwapInterval(<span class="integer">1</span>);

    <span class="comment">// NOTE: OpenGL error checks have been omitted for brevity</span>

    glGenBuffers(<span class="integer">1</span>, &amp;vertex_buffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);

    vertex_shader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertex_shader, <span class="integer">1</span>, &amp;vertex_shader_text, <span class="predefined-constant">NULL</span>);
    glCompileShader(vertex_shader);

    fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragment_shader, <span class="integer">1</span>, &amp;fragment_shader_text, <span class="predefined-constant">NULL</span>);
    glCompileShader(fragment_shader);

    program = glCreateProgram();
    glAttachShader(program, vertex_shader);
    glAttachShader(program, fragment_shader);
    glLinkProgram(program);

    mvp_location = glGetUniformLocation(program, <span class="string"><span class="delimiter">&quot;</span><span class="content">MVP</span><span class="delimiter">&quot;</span></span>);
    vpos_location = glGetAttribLocation(program, <span class="string"><span class="delimiter">&quot;</span><span class="content">vPos</span><span class="delimiter">&quot;</span></span>);
    vcol_location = glGetAttribLocation(program, <span class="string"><span class="delimiter">&quot;</span><span class="content">vCol</span><span class="delimiter">&quot;</span></span>);

    glEnableVertexAttribArray(vpos_location);
    glVertexAttribPointer(vpos_location, <span class="integer">2</span>, GL_FLOAT, GL_FALSE,
                          <span class="keyword">sizeof</span>(vertices[<span class="integer">0</span>]), (<span class="directive">void</span>*) <span class="integer">0</span>);
    glEnableVertexAttribArray(vcol_location);
    glVertexAttribPointer(vcol_location, <span class="integer">3</span>, GL_FLOAT, GL_FALSE,
                          <span class="keyword">sizeof</span>(vertices[<span class="integer">0</span>]), (<span class="directive">void</span>*) (<span class="keyword">sizeof</span>(<span class="predefined-type">float</span>) * <span class="integer">2</span>));

    <span class="keyword">while</span> (!glfwWindowShouldClose(window))
    {
        <span class="predefined-type">float</span> ratio;
        <span class="predefined-type">int</span> width, height;
        mat4x4 m, p, mvp;

        glfwGetFramebufferSize(window, &amp;width, &amp;height);
        ratio = width / (<span class="predefined-type">float</span>) height;

        glViewport(<span class="integer">0</span>, <span class="integer">0</span>, width, height);
        glClear(GL_COLOR_BUFFER_BIT);

        mat4x4_identity(m);
        mat4x4_rotate_Z(m, m, (<span class="predefined-type">float</span>) glfwGetTime());
        mat4x4_ortho(p, -ratio, ratio, -<span class="float">1</span>.f, <span class="float">1</span>.f, <span class="float">1</span>.f, -<span class="float">1</span>.f);
        mat4x4_mul(mvp, p, m);

        glUseProgram(program);
        glUniformMatrix4fv(mvp_location, <span class="integer">1</span>, GL_FALSE, (<span class="directive">const</span> GLfloat*) mvp);
        glDrawArrays(GL_TRIANGLES, <span class="integer">0</span>, <span class="integer">3</span>);

        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glfwDestroyWindow(window);

    glfwTerminate();
    exit(EXIT_SUCCESS);
}

<span class="comment">//! [code]</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_q_a">Q&amp;A</h2>
<div class="sectionbody">
<div class="qlist qanda">
<ol>
<li>
<p><em>How does Synapse differ from Boost Signals 2, which is also "non-intrusive"?</em></p>
<p>The main design difference is that in Boost Signals 2 emitting a signal requires a signal object. This is significant because in general it is not trivial to associate a Boost Signals 2 signal object with 3rd-party objects. When using Synapse such association is not necessary because the 3rd-party object itself can be passed to <code>emit</code>.</p>
</li>
<li>
<p><em>What is the design rationale for ignoring the value returned by connected functions?</em></p>
<p>A typical use case for Synapse is when the caller of <code>emit</code> doesn&#8217;t care if there are 0, 1 or many connected functions. Allowing return values makes the zero/many case quite tricky to deal with. On the other hand, passing a reference or a pointer to <code>emit</code> to return/accumulate values from any number of connected functions (if needed) is simpler and fits that case nicely.</p>
</li>
<li>
<p><em>Is there a way to stop the emit loop before all connected functions have been called?</em></p>
<p>No, except by throwing an exception.</p>
</li>
<li>
<p><em>I am concerned about code size, does Synapse use a lot of templates?</em></p>
<p>Yes, there are templates instantiated for each signal type. This is done so that the dispatch by signal type occurs at compile-time, leaving only emitter dispatch at run-time. However, static types are erased as soon as possible, so template bloat is kept to a minimum.</p>
</li>
<li>
<p><em>I do not need thread-safety, is there a way to configure Synapse to eliminate thread safety overhead?</em></p>
<p>Most data structures in Synapse are not thread-safe, instead they are thread-local. The overhead of using the library across multiple threads is contained only in <code>thread_local_queue.cpp</code>, which is an optional component.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>